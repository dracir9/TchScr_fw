//=========================================================
// src/myProject_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
#include <string.h>
#include "InitDevice.h"
#include "TouchScreen.h"
#include "SMBus.h"
// $[Generated Includes]
// [Generated Includes]$

int16_t dx = 320;
int16_t rx_min = 110;
int16_t rx_max = 780;

int16_t dy = 480;
int16_t ry_min = 65;
int16_t ry_max = 885;

uint16_t p_min = 100;
uint16_t p_max = 20000;

bool touchIRQ = false;
bool buttonIRQ = false;
bool flipXY = false;

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup (void)
{
  // $[SiLabs Startup]
  // [SiLabs Startup]$
}
//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main (void)
{
	Vec2 point;
	bool pressed = false;
	bool lastPressed = false;
	uint16_t lastP = 0;

	// Call hardware initialization routine
	enter_DefaultMode_from_RESET();

	TCON_IE0 = 0;	// Clear external interrupt

	// Enable interrupts
	IE_EA = 1;

	while (1)
	{
		if (wakeFromIdle)
		{
			wakeFromIdle = false;
			startTchRead();
		}
		if (readComplete)
		{
			readComplete = false;
			if (touchPoint.z > p_min && touchPoint.z < p_max)
			{
				if (touchPoint.z > lastP)
				{
					pressed = true;

					// Interpolate
					//point.x = x_min + (point.x - rx_min) * (x_max - x_min)/(rx_max-rx_min); // -> 41 Cycles
					//point.x = (point.x - rx_min) * x_max/(rx_max-rx_min); // ->28 Cycles
					//point.x = (int32_t)(point.x - rx_min) * x_max/(rx_max-rx_min); // ->130 Cycles
					//point.x = point.x * a + rx_min; // -> 200
					if (flipXY)
					{
						point.y = (int32_t)(touchPoint.x - rx_min) * dx/rx_max; // ->125 Cycles
						point.x = (int32_t)(touchPoint.y - ry_min) * dy/ry_max;
					}
					else
					{
						point.x = (int32_t)(touchPoint.x - rx_min) * dx/rx_max; // ->125 Cycles
						point.y = (int32_t)(touchPoint.y - ry_min) * dy/ry_max;
					}

					LAST_POINT = point;

					if (touchIRQ)
					{
						while(SMB_BUSY);
						// Fill data to send
						SMB_DATA_OUT_MASTER[0] = ((uint8_t*)&point.x)[1];
						SMB_DATA_OUT_MASTER[1] = ((uint8_t*)&point.x)[0];
						SMB_DATA_OUT_MASTER[2] = ((uint8_t*)&point.y)[1];
						SMB_DATA_OUT_MASTER[3] = ((uint8_t*)&point.y)[0];
						// Start write
						SMB_Write(ESP_ADDR, 4);
					}
				}
				else
					pressed = false;
				lastP = touchPoint.z;

				startTchRead();
			}
			else
			{
				lastP = 0;
				pressed = false;
				setIdle();
			}

			if (!lastPressed && pressed) touchState = TCH_PRESS;
			else if (lastPressed && pressed) touchState = TCH_HOLD;
			else if (lastPressed && !pressed) touchState = TCH_RELEASE;
			else touchState = TCH_FREE;

			// Update buttons

			if (touchState != TCH_FREE && checkButtons(point.x, point.y) != -1 && buttonIRQ)
			{
				while(SMB_BUSY);
				SMB_DATA_OUT_MASTER[0] = activeBtn;
				SMB_Write(ESP_ADDR, 1);
			}

			lastPressed = pressed;
		}

		if (DATA_READY)
		{
			switch (TCH_CMD)
			{
			case TCH_CMD_CAL:
				((uint8_t*)&dx)[1] = SMB_DATA_IN_SLAVE[0];
				((uint8_t*)&dx)[0] = SMB_DATA_IN_SLAVE[1];
				((uint8_t*)&rx_min)[1] = SMB_DATA_IN_SLAVE[2];
				((uint8_t*)&rx_min)[0] = SMB_DATA_IN_SLAVE[3];
				((uint8_t*)&rx_max)[1] = SMB_DATA_IN_SLAVE[4];
				((uint8_t*)&rx_max)[0] = SMB_DATA_IN_SLAVE[5];
				((uint8_t*)&dy)[1] = SMB_DATA_IN_SLAVE[6];
				((uint8_t*)&dy)[0] = SMB_DATA_IN_SLAVE[7];
				((uint8_t*)&ry_min)[1] = SMB_DATA_IN_SLAVE[8];
				((uint8_t*)&ry_min)[0] = SMB_DATA_IN_SLAVE[9];
				((uint8_t*)&ry_max)[1] = SMB_DATA_IN_SLAVE[10];
				((uint8_t*)&ry_max)[0] = SMB_DATA_IN_SLAVE[11];
				break;

			case TCH_CMD_THR:
				((uint8_t*)&p_min)[1] = SMB_DATA_IN_SLAVE[0];
				((uint8_t*)&p_min)[0] = SMB_DATA_IN_SLAVE[1];
				((uint8_t*)&p_max)[1] = SMB_DATA_IN_SLAVE[2];
				((uint8_t*)&p_max)[0] = SMB_DATA_IN_SLAVE[3];
				break;

			case TCH_CMD_BTN:
				editButton(SMB_DATA_IN_SLAVE[0], SMB_DATA_IN_SLAVE[1],
				SMB_DATA_IN_SLAVE[2] | SMB_DATA_IN_SLAVE[3] << 8,
				SMB_DATA_IN_SLAVE[4] | SMB_DATA_IN_SLAVE[5] << 8,
				SMB_DATA_IN_SLAVE[6] | SMB_DATA_IN_SLAVE[7] << 8,
				SMB_DATA_IN_SLAVE[8] | SMB_DATA_IN_SLAVE[9] << 8);
				break;

			case TCH_CMD_IRQ:
				touchIRQ = SMB_DATA_IN_SLAVE[0] & 0x01;
				buttonIRQ = SMB_DATA_IN_SLAVE[0] & 0x02;
				flipXY = SMB_DATA_IN_SLAVE[0] & 0x04;
				break;
			}
			DATA_READY = false;
		}
	}
}
